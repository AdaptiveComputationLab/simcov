# quality cutoff for rejecting bases as bad during kmer counting
# quality encoding is logarithmic, so the probability of an error is:
# cutoff 10: 10% chance
# cutoff 20: 1% chance
# cutoff 30: 0.1% chance
add_definitions(-DKCOUNT_QUAL_CUTOFF=20)
# if defined will filter out all kmers after a bad quality score (2) in the read
add_definitions(-DKCOUNT_FILTER_BAD_QUAL_IN_READ)
# false positive rate for bloom filter
add_definitions(-DKCOUNT_BLOOM_FP=0.05)

# use colors in the output
add_definitions(-DCONFIG_USE_COLORS)

# use the bytell hash table implementation
add_definitions(-DUSE_BYTELL)

# max allowed alignments per read (to reduce overhead & imbalance) - set to 0 to have no limit
add_definitions(-DKLIGN_MAX_ALNS_PER_READ=20)
# limit on how many contigs to fetch for a read at a time - this is across all ranks, so a form of buffering
add_definitions(-DKLIGN_CTG_FETCH_BUF_SIZE=100000)
# decreasing this value increases the alignment computation time, and it may improve results slightly
add_definitions(-DKLIGN_SEED_SPACE=8)
# how many bases to add on either end of longest sequence when aligning a substring
add_definitions(-DKLIGN_EXPAND_BASES=5)
# max number of unaligned bases to allow on the side of an alignment
add_definitions(-DKLIGN_UNALIGNED_THRES=1)

# controls depth matching in cgraph
add_definitions(-DCGRAPH_DEPTH_DIFF_THRES=0.1)
add_definitions(-DCGRAPH_MAX_DEPTH_DIFF=15)
add_definitions(-DCGRAPH_MIN_DEPTH_DIFF=5)
# controls extent of search for matching depth in cgraph
add_definitions(-DCGRAPH_MAX_SEARCH_LEVEL=5)
add_definitions(-DCGRAPH_MAX_QUEUE_SIZE=100)
# max number of entries in vertex cache or in edge cache
add_definitions(-DCGRAPH_MAX_CACHE_SIZE=2000000)
# max allowed degree in contig graph
add_definitions(-DCGRAPH_MAX_DEGREE=100)
# threshold multiplier for best supported path over second best
add_definitions(-DCGRAPH_WALK_SUPPORT_THRES=3)
# Max number of mismatches allowed when closing gaps - any more than and the scaffold will be broken
add_definitions(-DCGRAPH_GAP_CLOSING_OVERLAP_MISMATCH_THRES=1)
# This should be a parameter - it is a good way of tuning errors vs ctgy - the higher it is, the higher the errors and ctgy
# The max permissible number of mismatches in the overlap when closing spans
# FIXME: should this be a parameter??
add_definitions(-DCGRAPH_SPAN_OVERLAP_MISMATCH_THRES=1)
# another good candidate for errors v ctgy tradeoff
# For SSW alignments in gap closing: max number of mismatches allowed in the alignment
add_definitions(-DCGRAPH_MAX_MISMATCHES_THRES=3)
# Minimum contig length for computing TNF
add_definitions(-DCGRAPH_MIN_TNF_CLEN=1000)
# TNF probability threshold to choose one branch over another
add_definitions(-DCGRAPH_WALK_TNF_THRES=0.75)

# parameters for SSW aligner
add_definitions(-DSSW_MATCH_SCORE=1)
add_definitions(-DSSW_MISMATCH_COST=1)
add_definitions(-DSSW_GAP_OPENING_COST=1)
add_definitions(-DSSW_GAP_EXTENDING_COST=1)
add_definitions(-DSSW_AMBIGUITY_COST=1)
# previous defaults
#add_definitions(-DSSW_MISMATCH_COST=3)
#add_definitions(-DSSW_GAP_OPENING_COST=5)
#add_definitions(-DSSW_GAP_EXTENDING_COST=2)
#add_definitions(-DSSW_AMBIGUITY_COST=2)

# max and min kmer lengths for local assembly kmer walks
add_definitions(-DLASSM_MAX_KMER_LEN=121)
add_definitions(-DLASSM_MIN_KMER_LEN=21)
# size of shift in iterative kmer walks
add_definitions(-DLASSM_SHIFT_SIZE=8)
# minimum score for low quality base
add_definitions(-DLASSM_MIN_QUAL=10)
# minimum score for high quality base
add_definitions(-DLASSM_MIN_HI_QUAL=20)
# parameters for depth matching
add_definitions(-DLASSM_MIN_VIABLE_DEPTH=0.2)
add_definitions(-DLASSM_MIN_EXPECTED_DEPTH=0.3)
# for fork resolution
add_definitions(-DLASSM_RATING_THRES=0)
# limit to restrict the computational overhead
add_definitions(-DLASSM_MAX_COUNT_MERS_READS=3000)
